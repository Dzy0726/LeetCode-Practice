# HOT 100

## Day 1

### 1.[两数之和](https://leetcode.cn/problems/two-sum/)

建立空的哈希表，查target减去当前元素在不在哈希表，在就查到了一组答案，直接return；不在的话把当前的元素加入哈希表，先检查后加入能避免同一个元素使用两次。

复习的点：

哈希表的建立：直接建，可以不初始化

查找，迭代器 auto it = hashTable.find()

是否找到看it，是否是end()

插入的话直接 hashTable[key] = value



### 2.[字母异位词分组](https://leetcode.cn/problems/group-anagrams/)

ate, eat, tea 认为是一组，可以对这个string排序，排序完都是aet，这就可以作为是hashtable 的key， value就是原字符串。

这样遍历一次，得到若干string:[string]，再把[string]加到result就得到最后的答案。

难点是想到第一步：两个字符串互为字母异位词，当且仅当两个字符串包含的字母相同。**同一组字母异位词中的字符串具备相同点**，可以使用相同点作为一组字母异位词的标志，使用哈希表存储每一组字母异位词，哈希表的键为一组字母异位词的标志，哈希表的值为一组字母异位词列表。



另外，push_back和emplace_back：

1. **构造方式不同**：
   - `push_back`：需要传入一个对象，将该对象复制或移动到容器中。这意味着如果传入的是构造参数，需要先构造临时对象，再将其传递给容器。
   - `emplace_back`：直接在容器的内存位置处构造对象，不需要创建临时对象。它可以直接传递构造函数的参数，由容器内部调用构造函数来创建对象。
2. **性能差异**：
   - `push_back` 可能涉及一次对象的拷贝或移动操作，尤其是在对象较大或复杂时，性能开销会更大。
   - `emplace_back` 由于是在容器内部直接构造对象，避免了临时对象的创建和拷贝/移动，性能更高，尤其在需要构造复杂对象时效率更优。
3. **适用场景**：
   - `push_back` 适用于已经存在的对象，直接将对象添加到容器中。
   - `emplace_back` 适用于需要在添加时构造对象的情况，尤其是在构造对象时需要传递多个参数。