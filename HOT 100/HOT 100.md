# HOT 100

## Day 1

### 1.[两数之和](https://leetcode.cn/problems/two-sum/)

建立空的哈希表，查target减去当前元素在不在哈希表，在就查到了一组答案，直接return；不在的话把当前的元素加入哈希表，先检查后加入能避免同一个元素使用两次。

复习的点：

哈希表的建立：直接建，可以不初始化

查找，迭代器 auto it = hashTable.find()

是否找到看it，是否是end()

插入的话直接 hashTable[key] = value



### 2.[字母异位词分组](https://leetcode.cn/problems/group-anagrams/)

ate, eat, tea 认为是一组，可以对这个string排序，排序完都是aet，这就可以作为是hashtable 的key， value就是原字符串。

这样遍历一次，得到若干string:[string]，再把[string]加到result就得到最后的答案。

难点是想到第一步：两个字符串互为字母异位词，当且仅当两个字符串包含的字母相同。**同一组字母异位词中的字符串具备相同点**，可以使用相同点作为一组字母异位词的标志，使用哈希表存储每一组字母异位词，哈希表的键为一组字母异位词的标志，哈希表的值为一组字母异位词列表。



另外，push_back和emplace_back：

1. **构造方式不同**：
   - `push_back`：需要传入一个对象，将该对象复制或移动到容器中。这意味着如果传入的是构造参数，需要先构造临时对象，再将其传递给容器。
   - `emplace_back`：直接在容器的内存位置处构造对象，不需要创建临时对象。它可以直接传递构造函数的参数，由容器内部调用构造函数来创建对象。
2. **性能差异**：
   - `push_back` 可能涉及一次对象的拷贝或移动操作，尤其是在对象较大或复杂时，性能开销会更大。
   - `emplace_back` 由于是在容器内部直接构造对象，避免了临时对象的创建和拷贝/移动，性能更高，尤其在需要构造复杂对象时效率更优。
3. **适用场景**：
   - `push_back` 适用于已经存在的对象，直接将对象添加到容器中。
   - `emplace_back` 适用于需要在添加时构造对象的情况，尤其是在构造对象时需要传递多个参数。

## Day 

### 3. [最长连续序列](https://leetcode.cn/problems/longest-consecutive-sequence/)

要在On内实现，不能排序（快排nlogn）

首先可以想到要去重，比如 0，1，1，2，就算能排序，不去重的话也会出错。

就可以用unordered_set，但又不能排序，怎么确定有没有连续的数字呢？

最朴素的思路就是选一个数x，然后从后面一直找有没有x+1，找到之后再找x+2，x+3，

是On方级别，外层遍历n次，内层遍历n次



但是这个过程中有很多重复的比较，比如已经确定了x，x+1，x+2存在，那么对于x+1，就不用再去比x+2和后面的。



只要确保x是潜在连续数字的第一个，是第一个再比，不是第一个就认为已经比过了，不再比直接跳过。

这样的话每个数只进入内层循环一次 On复杂度



unordered_set有一个 count函数，看有几个值

进入内层循环前要判断 该数字是不是连续数字的第一个，如果前面有，比如当前3，前面有2，在2的时候已经判断过2、3、4了，3就不需要再进内层循环，直接跳过。