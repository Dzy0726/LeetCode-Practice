# **代码随想录算法训练营第一天| 704. 二分查找+27. 移除元素**

## LeetCode 704.二分查找

### 题目链接

[704.二分查找]: https://leetcode.cn/problems/binary-search/

给定一个 `n` 个元素有序的（升序）整型数组 `nums` 和一个目标值 `target` ，写一个函数搜索 `nums` 中的 `target`，如果目标值存在返回下标，否则返回 `-1`。
**示例 1:**

```
输入: nums = [-1,0,3,5,9,12], target = 9
输出: 4
解释: 9 出现在 nums 中并且下标为 4
```

**示例 2:**

```
输入: nums = [-1,0,3,5,9,12], target = 2
输出: -1
解释: 2 不存在 nums 中因此返回 -1
```

**提示：**

1. 你可以假设 `nums` 中的所有元素是不重复的。
2. `n` 将在 `[1, 10000]`之间。
3. `nums` 的每个元素都将在 `[-9999, 9999]`之间。

[代码随想录]: https://programmercarl.com/0704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE

### 思路

数组升序且元素不重复，所以每轮取数组“中间值”与目标值比较，若目标值小于中间值，到左侧区间进行下一轮比较；反之，则到右侧区间进行下一轮比较，直至找到或发现不存在。

### 代码

```c++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int length = nums.size();
        int left = 0, right = length - 1;
        while(left <= right) {
            int mid = (left + right) / 2 ;
            if (target == nums[mid]) {
                return mid;
            } else if (target < nums[mid]) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        return -1;
    }
};
```

### 时空复杂度

- 时间复杂度：数组长度为n，第一次查找剩余n/2，第二次剩余n/4，第三次剩余n/8……假设查找了k次，则剩余n/2^k，最坏情况是查找到最后一个元素，即`n/2^k = 1`，解得`k = log_2(n)`，即时间复杂度为O(log(n)).
- 空间复杂度：创建了几个变量，所以空间复杂度为O(1).

### 出现的问题

第一次提交跳出循环的条件与后面左右边界的移动没有匹配，导致每次查询到数组中只剩一个值，即`left==right`时，不会进入循环，导致返回`-1`。

### 学习

看完代码随想录704的讲解，果然自己就是犯了最标准的错误——**对区间的定义没有想清楚**。跳出循环的判断到底是`left <= right` 还是`left < right`，区别就在于当`left == right`时，有没有意义。由此引出二分法的两种写法，**左闭右闭**和**左闭右开**。

1. 左闭右闭：这种情况下，`left == right`是有意义的，也就是我遇到的区间缩小到只剩下一个值的情况。在这种情况下，划分下一轮的区间时，从left到right的每一个元素都小于或大于mid值，所以在上一轮结束时，`left = mid + 1` 或 `right = mid - 1`，区间完全被缩减到mid的一侧。
2. 左闭右开：在这种情况下，`left == right`没有意义，因为右侧是开区间说明右侧的值在本轮中取不到，那自然左侧边界不可能和右侧边界相等。所以在上一轮结束时，如果目标值小于中间值，则`right = mid`。

### 小结

对我来说，我更容易接受理解在本轮结束时用`left = mid + 1` 或 `right = mid - 1`划分一轮的区间。但每次在二分之前要先想清楚，选择左闭右闭还是左闭右开。

多读多想：

> 大家写二分法经常写乱，主要是因为**对区间的定义没有想清楚，区间的定义就是不变量**。要在二分查找的过程中，保持不变量，就是在while寻找中每一次边界的处理都要坚持根据区间的定义来操作，这就是**循环不变量**规则。



## LeetCode 27. 移除元素

### 题目链接

[27.移除元素]: (https://leetcode.cn/problems/remove-element/)

给你一个数组 `nums` 和一个值 `val`，你需要 **[原地](https://baike.baidu.com/item/原地算法)** 移除所有数值等于 `val` 的元素，并返回移除后数组的新长度。

不要使用额外的数组空间，你必须仅使用 `O(1)` 额外空间并 **[原地 ](https://baike.baidu.com/item/原地算法)修改输入数组**。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

**示例 1：**

```
输入：nums = [3,2,2,3], val = 3
输出：2, nums = [2,2]
解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。
```

**示例 2：**

```
输入：nums = [0,1,2,2,3,0,4,2], val = 2
输出：5, nums = [0,1,3,0,4]
解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。
```

**提示：**

- `0 <= nums.length <= 100`
- `0 <= nums[i] <= 50`
- `0 <= val <= 100`

### 思路

题目着重强调原地修改数组，移除所有数值等于val的元素，我首先想到的就是**数组元素是不能被删除，只能被覆盖**，于是进一步想到了交换数组两个元素。当找到值为val的元素时，就把它和数组末尾的元素交换，并且将数组长度减1，就完成了“原地删除”的操作。在这个思路下继续优化一些细节，比如既然要**删除**交换到末尾元素，其实用**交换**就多此一举，直接用末尾元素覆盖当前元素即可；还要注意在覆盖后，也要查验当前元素值是否为val。

### 代码

```c++
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int length = nums.size();
        int i = 0;
        while(i < length) {
            if (nums[i] == val) {
                nums[i] = nums[length - 1];
                length--;
            } else {
                i++;
            }
        }
        return length;
    }
};
```

### 时空复杂度

- 时间复杂度：遍历一次数组，O(n).
- 空间复杂度：原地修改，空间复杂度O(1).

### 出现的问题

可能是做过的原因，一次AC，没有出现什么问题。上手习惯于写for循环，但是i并不是每次循环都增加，如果出现了覆盖，还需要检查当前位置覆盖之后的元素是否依然等于val，所以感觉while循环在本题更简单。

### 学习

- 暴力解法：第一思路没有想到暴力解法，但是暴力法还是很好理解的，两层循环，第一层找到值为val的元素，第二层循环从后往前覆盖。

- 双指针法：之前有了解过双指针法，但是这道题还是没反应过来直接用。双指针法首先要定义快慢指针，在本题中

  > 快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组
  >
  > 慢指针：指向更新 新数组下标的位置

  慢指针就是找到值为val的元素，相当于暴力法中的第一层for循环；而快指针就是暴力法中的第二层循环，找到后面的元素将值为val的元素覆盖。

### 小结

我的方法好像不属于快慢指针，看了leetcode的其他题解，发现一种更简洁的方法，类似于我的思路的逆向思维。找到值为val的元素，将末尾的一个元素取来覆盖它并且将数组长度减1；也可以在遍历过程中，如果当前元素值不等于val，就保留，等于val就跳过，只需有一个新的下标k。

```c++
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int length = nums.size();
        int k = 0;
        for (int i = 0; i < length; i++) {
            if (nums[i] != val) {
                nums[k++] = nums[i];
            }
        }
        return k;
    }
};
```

这种方法也算是快慢指针，k为慢指针指向最后应该在数组中的元素，i为快指针寻找值等于（或者说不等于）val的元素。