没想清楚这个链表相等是怎么一回事，一直以为像kmp算法那样要匹配，写了半天没搞出来

后面才知道链表相等首先要长度相等…



注意几个细节：

1.算链表长度的循环要求是当前这个不空就行，这样就能算长度加一；不是下一个不空，下一个不空保证的是当前当前不指到空节点

2.A和B谁更长？ gap可以用表达式求出来，但是链表还得分情况写，所以不如直接统一，不管谁长，把长的交换到A，短的交换到B

```cpp
// 让curA为最长链表的头，lenA为其长度
        if (lenB > lenA) {
            swap (lenA, lenB);
            swap (curA, curB);
        }
```

这样就不用分情况讨论，学习

