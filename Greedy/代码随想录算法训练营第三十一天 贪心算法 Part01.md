# 代码随想录算法训练营第三十一天| 贪心算法 Part01

## 今日题目

455.[分发饼干](https://leetcode.cn/problems/assign-cookies/)

376.[摆动序列](https://leetcode.cn/problems/wiggle-subsequence/)

53.[最大子数组和](https://leetcode.cn/problems/maximum-subarray/)

## 理论基础

1. 什么是贪心：选择每一阶段的局部最优，从而达到全局最优。
2. 什么时候用贪心：手动模拟一下感觉可以局部最优推出整体最优，而且想不到反例，那么就试一试贪心。

## LeetCode 455.分发饼干

### 题目

假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。

对每个孩子 `i`，都有一个胃口值 `g[i]`(，)这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 `j`，都有一个尺寸 `s[j]`( )。如果 `s[j] >= g[i]`，我们可以将这个饼干 `j` 分配给孩子 `i` ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。

> 输入: g = [1,2,3], s = [1,1] 输出: 1 解释:你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。 虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。 所以你应该输出1。

### 思路

这道题非常简单，从大到小匹配两个数组，如果满足的话result++，不满足的话g数组向小的方向移动，直到比较完其中一个数组。

### 代码

```C++
class Solution {
public:
    int findContentChildren(vector<int>& g, vector<int>& s) {
        sort(g.begin(), g.end());
        sort(s.begin(), s.end());
        int result = 0;
        int i = g.size() - 1, j = s.size() - 1;
        while (i >=0 && j >= 0) {
            if (s[j] >= g[i]) {
                result++;
                i--;
                j--;
            } else {
                i--;
            }
        }
        return result;
    }
};
```

### 时空复杂度

时间复杂度：

1. `sort(g.begin(), g.end());` 的时间复杂度是 `O(NlogN)`，其中 `N` 是数组 `g` 的长度。
2. `sort(s.begin(), s.end());` 的时间复杂度是 `O(MlogM)`，其中 `M` 是数组 `s` 的长度。
3. `while` 循环的时间复杂度是 `O(min(M, N))`，因为它遍历两个数组中较短的一个，每次循环中最多减少一个 `g` 或 `s` 中的元素。

综合起来，总时间复杂度是两个排序操作的复杂度加上 `while` 循环的复杂度，即 `O(NlogN + MlogM`。

空间复杂度：空间复杂度为O(1).

### 学习与小结

这里的局部最优就是大饼干喂给胃口大的，充分利用饼干尺寸喂饱一个，全局最优就是喂饱尽可能多的小孩。找不出反例，就试试贪心。

## LeetCode 376. 摆动序列

### 题目

如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 **摆动序列 。**第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。

- 例如， `[1, 7, 4, 9, 2, 5]` 是一个 **摆动序列** ，因为差值 `(6, -3, 5, -7, 3)` 是正负交替出现的。
- 相反，`[1, 4, 7, 2, 5]` 和 `[1, 7, 4, 5, 5]` 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。

**子序列** 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。

给你一个整数数组 `nums` ，返回 `nums` 中作为 **摆动序列** 的 **最长子序列的长度** 。

> 示例 1：
>
> 输入：nums = [1,7,4,9,2,5] 输出：6 解释：整个序列均为摆动序列，各元素之间的差值为 (6, -3, 5, -7, 3) 。
>
> 示例 2：
>
> 输入：nums = [1,17,5,10,13,15,10,5,16,8] 输出：7 解释：这个序列包含几个长度为 7 摆动序列。 其中一个是 [1, 17, 10, 13, 10, 16, 8] ，各元素之间的差值为 (16, -7, 3, -3, 6, -8) 。

### 思路

我想的局部最优解就是如果先前子序列是摆动序列，到某处中断了，就跳过当前这个值继续向后找，看是否还有能让子序列继续成为摆动序列的值。

如：nums = [1,17,5,10,13,15,10,5,16,8]

到13的时候，摆动序列中断了，前面是小大小大，应该找一个比10小的数，于是跳过13向后找，找到5就说明找到了，然后继续向后比较。

通过几次提交发现测试用例有几个数相等情况较多，所以之前用于记录该找一个大数还是小数的变量应该改成三个状态：大数、小数、相等的数，分别处理不同的情况。

### 代码

```C++
class Solution {
public:
    int wiggleMaxLength(vector<int>& nums) {
        if (nums.size() == 1) return 1;
        int result = 1;
        int big; 
        if (nums[1] > nums[0]) {
            big = 1;
            result++;
        } else if (nums[1] < nums[0]) {
            big = 0;
            result++;
        } else {
            big = 2;
        }
        for (int i = 2; i < nums.size(); i++) {
            if (big == 1) {
                if (nums[i] < nums[i - 1]) {
                    result++;
                    big = 0;
                }
            } else if (big == 0){
                if (nums[i] > nums[i - 1]) {
                    result++;
                    big = 1;
                }
            } else {
                if (nums[i] > nums[i - 1]) {
                    result++;
                    big = 1;
                } else if (nums[i] < nums[i - 1]) {
                    result++;
                    big = 0;
                } else {
                    continue;
                }
            }
        }
        return result;
    }
};
```

### 时空复杂度

时间复杂度：遍历一次数组，时间复杂度为O(n).

空间复杂度：空间复杂度为O(1).

### 学习与小结

![img](https://pkdwxagc9o.feishu.cn/space/api/box/stream/download/asynccode/?code=M2I5YWZkMGQ4ZmVmOTg2NjU5ZGI1YmQ5ZThkNGYxYjVfR3ZrUmk0N0lpd0g4OTRJMkhKeGVKV1Bld1dSUjY1N2JfVG9rZW46VGlESmJYWFhLb3Q1QXh4T0R3ZWNQMWhVbmR4XzE3MDYyMzY4Nzk6MTcwNjI0MDQ3OV9WNA)

另一种贪心的思路是找峰值（极值），其实是跳过（删除）非极值元素。于是有：

局部最优：删除单调坡度上的节点（不包括单调坡度两端的节点），那么这个坡度就可以有两个局部峰值（极大值或极小值）。

整体最优：整个序列有最多的局部峰值，从而达到最长摆动序列。

除此之外还要考虑：

1. 情况一：上下坡中有平坡
2. 情况二：数组首尾两端
3. 情况三：单调坡中有平坡

```C++
class Solution {
public:
    int wiggleMaxLength(vector<int>& nums) {
        if (nums.size() <= 1) return nums.size();
        int curDiff = 0; // 当前一对差值
        int preDiff = 0; // 前一对差值
        int result = 1;  // 记录峰值个数，序列默认序列最右边有一个峰值
        for (int i = 0; i < nums.size() - 1; i++) {
            curDiff = nums[i + 1] - nums[i];
            // 出现峰值
            if ((preDiff <= 0 && curDiff > 0) || (preDiff >= 0 && curDiff < 0)) {
                result++;
                preDiff = curDiff; // 注意这里，只在摆动变化的时候更新prediff
            }
        }
        return result;
    }
};
```

直接将代码精简了一半，思路也更加清晰了，无需分类讨论之前前面是增是减，只要前面的状态和现在的状态不同，就记录result++，否则就进入下一次循环，跳过当前值。

另外就是要考虑特殊情况，平坡的情况。

## LeetCode 53. 最大子序和

### 题目

给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**子数组** 是数组中的一个连续部分。

> 示例 1：
>
> 输入：nums = [-2,1,-3,4,-1,2,1,-5,4] 输出：6 解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
>
> 示例 2：
>
> 输入：nums = [1] 输出：1
>
> 示例 3：
>
> 输入：nums = [5,4,-1,7,8] 输出：23

### 思路

这道题没做出来，脑海里一闪而过的想法很快被自己否决了。看到第一个示例，想着要求最大和必须得是从正数开始相加，才有可能出现最大和，但是很快想到如果数组都是负数又该怎么办？于是陷入了思考……没有想到正确的思路。

但其实局部最优：当前“连续和”为负数的时候立刻放弃，从下一个元素重新计算“连续和”，因为负数加上下一个元素 “连续和”只会越来越小。

全局最优：选取最大“连续和”

局部最优的情况下，并记录最大的“连续和”，可以推出全局最优。

如果都是负数，那就相当于每遍历到一个新的数都要“放弃”当前的连续和，用现在的值当做最大的连续和与之前的最大值比较——这不就有方法了吗？用两个变量来记录，一个记录当前最大的连续和，一个记录当前连续的序列和，后者大于前者就更新前者为后者。

遍历 nums，从头开始用 count 累积，如果 count 一旦加上 nums[i]变为负数，那么就应该从 nums[i+1]开始从 0 累积 count 了，因为已经变为负数的 count，只会拖累总和。

这相当于是暴力解法中的不断调整最大子序和区间的起始位置。

### 代码

```C++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int result = INT32_MIN;
        int count = 0;
        for (int i = 0; i < nums.size(); i++) {
            count += nums[i];
            if (count > result) {
                result = count;
            }
            if (count < 0) {
                count = 0;
            }
        }
        return result;
    }
};
```

### 时空复杂度

时间复杂度：时间复杂度为O(n).

空间复杂度：空间复杂度为O(1).

### 学习与小结

没有用两个变量来记录是解不出来的主要原因。只要count大于result就更新count，已经记录了当前的最大值，就不用再担心正数后面接负数要不要连续计算，还是中断；只有和变成负数才让count  = 0重新开始计算连续和。