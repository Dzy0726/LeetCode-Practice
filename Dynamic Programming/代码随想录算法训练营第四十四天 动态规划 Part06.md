# 代码随想录算法训练营第四十四天| 动态规划 Part06

## 今日题目

518.[零钱兑换 II](https://leetcode.cn/problems/coin-change-ii/)

377.[组合总和 Ⅳ](https://leetcode.cn/problems/combination-sum-iv/)

## LeetCode 518.零钱兑换 II

### 题目

给你一个整数数组 `coins` 表示不同面额的硬币，另给一个整数 `amount` 表示总金额。

请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 `0` 。

假设每一种面额的硬币有无限个。 

题目数据保证结果符合 32 位带符号整数。

> 示例 1：
>
> 输入：amount = 5, coins = [1, 2, 5] 输出：4 解释：有四种方式可以凑成总金额： 5=5 5=2+2+1 5=2+1+1+1 5=1+1+1+1+1
>
> 示例 2：
>
> 输入：amount = 3, coins = [2] 输出：0 解释：只用面额 2 的硬币不能凑成总金额 3 。
>
> 示例 3：
>
> 输入：amount = 10, coins = [10]  输出：1

### 思路

虽然花了很长时间，但最终是自己做出来了……

**求组合总数要累加！！！**

和昨天的分正负的那道题类似，都是找有几种方式可以构成目标值，就是求组合总数的问题，要对dp进行累加。

dp[j] = k的含义是使用coins[0]-coins[i]这i+1种硬币，构成价值为j的方法有k种。

如在coins = [1, 2, 5]下，i=1时，dp[3] = 2意思是使用1块、2块找零3块的方法有两种，分别是1+1+1和1+2。

dp[0]初始化为1，这道题可以理解成无论使用几种硬币，找零0元的方法都只有一种（不找零）。

所以递推公式就是dp[j] += dp[j-coins[i]]。

**那么遍历的顺序呢？**

纯完全背包求得装满背包的最大价值是多少，和凑成总和的元素有没有顺序没关系，即：有顺序也行，没有顺序也行。

而本题要求凑成总和的组合数，元素之间明确要求没有顺序。

所以纯完全背包是能凑成总和就行，不用管怎么凑的。本题是求凑出来的方案个数，且每个方案个数是为组合数。那么本题，两个for循环的先后顺序可就有说法了。

我们先来看外层for循环遍历物品（钱币），内层for遍历背包（金钱总额）的情况。

假设：coins[0] = 1，coins[1] = 5。

那么就是先把1加入计算，然后再把5加入计算，得到的方法数量只有{1, 5}这种情况。而不会出现{5, 1}的情况。所以这种遍历顺序中dp[j]里计算的是**组合数**。

如果把两个for交换顺序，背包容量的每一个值，都是经过 1 和 5 的计算，包含了{1, 5} 和 {5, 1}两种情况。此时dp[j]里算出来的就是排列数！

### 代码

```C++
class Solution {
public:
    int change(int amount, vector<int>& coins) {
        vector<int> dp(amount + 1, 0);
        dp[0] = 1;
        for (int i = 0; i < coins.size(); i++) {
            for (int j = 1; j <= amount; j++) {
                if (j >= coins[i]) {
                    dp[j] += dp[j - coins[i]];
                }
            }
        }
        return dp[amount];
    }
};
```

### 时空复杂度

时间复杂度: O(mn)，其中 m 是amount，n 是 coins 的长度

空间复杂度: O(m)

### 学习与小结

终于自己做出来一道题，肯定是有进步的，但是进步不是很明显，用时较长，主要是忘记了求组合数时要累加。

另外就是没有自发地想能否交换两个for循环的顺序，如果先遍历价值，也就是要找零多少（j），那么就变成了求排列。

## LeetCode 377.组合总和Ⅳ

### 题目

给你一个由 **不同** 整数组成的数组 `nums` ，和一个目标整数 `target` 。请你从 `nums` 中找出并返回总和为 `target` 的元素组合的个数。

题目数据保证答案符合 32 位整数范围。

> 示例 1：
>
> 输入：nums = [1,2,3], target = 4 输出：7 解释： 所有可能的组合为： (1, 1, 1, 1) (1, 1, 2) (1, 2, 1) (1, 3) (2, 1, 1) (2, 2) (3, 1) 请注意，顺序不同的序列被视作不同的组合。
>
> 示例 2：
>
> 输入：nums = [9], target = 3 输出：0

### 思路

有了上一题的铺垫，这道题就变得简单许多了，一定要手动模拟一次代码运行过程，明白每一个时间点dp的值是怎么来的。

个数可以不限使用，说明这是一个完全背包。

得到的集合是排列，说明需要考虑元素之间的顺序。

本题要求的是排列，那么这个for循环嵌套的顺序可以有说法了。

**如果求组合数就是外层****for循环****遍历物品，内层for遍历背包。**

**如果求排列数就是外层for遍历背包，内层****for循环****遍历物品。**

### 代码

```C++
class Solution {
public:
    int combinationSum4(vector<int>& nums, int target) {
        vector<unsigned int> dp(target + 1, 0);
        dp[0] = 1;
        for (int j = 1; j <= target; j++) {
            for (int i = 0; i < nums.size(); i++) {
                if (j >= nums[i]) dp[j] += dp[j - nums[i]];
            }
        }
        return dp[target];
    }
};
```

### 时空复杂度

时间复杂度: O(target * n)，其中 n 为 nums 的长度

空间复杂度: O(target)

### 学习与小结

C++测试用例有两个数相加超过int的数据，所以vector我用了unsigned int。