# 代码随想录算法训练营第三十八天| 动态规划 Part01

## 动态规划

1. 确定dp数组（dp table）以及下标的含义
2. 确定递推公式
3. dp数组如何初始化
4. 确定遍历顺序
5. 举例推导dp数组

## 今日题目

509.[斐波那契数](https://leetcode.cn/problems/fibonacci-number/)

70.[爬楼梯](https://leetcode.cn/problems/climbing-stairs/)

746.[使用最小花费爬楼梯](https://leetcode.cn/problems/min-cost-climbing-stairs/)

## LeetCode 509.斐波那契数

### 题目

**斐波那契数** （通常用 `F(n)` 表示）形成的序列称为 **斐波那契数列** 。该数列由 `0` 和 `1` 开始，后面的每一项数字都是前面两项数字的和。也就是：

F(0) = 0，F(1) = 1

F(n) = F(n - 1) + F(n - 2)，其中 n > 1

给定 `n` ，请计算 `F(n)` 。

### 思路

非常简单的入门题，规范的走一遍五部曲：

1. dp及下标含义：dp是斐波那契数，下标就是n，第几个斐波那契数；
2. 递推公式：题中给的公式；
3. 如何初始化：F0和F1
4. 遍历顺序：从前往后
5. 举例推导：正常推导

### 代码

```C++
class Solution {
public:
    int fib(int n) {
        if (n == 0) return 0;
        if (n == 1) return 1;
        return fib(n - 1) + fib(n - 2);
    }
};
```

### 时空复杂度

时间复杂度：时间复杂度为O(2^n).

空间复杂度：空间复杂度为O(n)，递归栈。

## LeetCode 70.爬楼梯

### 题目

假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。

每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？

> 示例 1：
>
> 输入：n = 2 输出：2 解释：有两种方法可以爬到楼顶。 1. 1 阶 + 1 阶 2. 2 阶
>
> 示例 2：
>
> 输入：n = 3 输出：3 解释：有三种方法可以爬到楼顶。 1. 1 阶 + 1 阶 + 1 阶 2. 1 阶 + 2 阶 3. 2 阶 + 1 阶

### 思路

一开始想到的是爬三楼就爬二楼和爬一楼的组合，然后递推写了4、5层发现就是斐波那契数列。

### 代码

```C++
class Solution {
public:
    int climbStairs(int n) {
        if (n < 3) return n;
        vector<int> dp(n + 1);
        dp[1] = 1, dp[2] = 2;
        for (int i = 3; i < n + 1; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }
};
```

### 时空复杂度

时间复杂度：时间复杂度为O(n).

空间复杂度：空间复杂度为O(n).

### 学习与小结

其实想的好像不太对，应该是先爬到n-1或n-2层，然后有两种方法，再爬一步或者爬两步，所以是dp[n-1]+dp[n-2].

## LeetCode 746.使用最小花费爬楼梯

### 题目

给你一个整数数组 `cost` ，其中 `cost[i]` 是从楼梯第 `i` 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。

你可以选择从下标为 `0` 或下标为 `1` 的台阶开始爬楼梯。

请你计算并返回达到楼梯顶部的最低花费。

> 示例 1：
>
> 输入：cost = [10,*15*,20] 输出：15 解释：你将从下标为 1 的台阶开始。 - 支付 15 ，向上爬两个台阶，到达楼梯顶部。 总花费为 15 。
>
> 示例 2：
>
> 输入：cost = [*1*,100,*1*,1,*1*,100,*1*,*1*,100,*1*] 输出：6 解释：你将从下标为 0 的台阶开始。 - 支付 1 ，向上爬两个台阶，到达下标为 2 的台阶。 - 支付 1 ，向上爬两个台阶，到达下标为 4 的台阶。 - 支付 1 ，向上爬两个台阶，到达下标为 6 的台阶。 - 支付 1 ，向上爬一个台阶，到达下标为 7 的台阶。 - 支付 1 ，向上爬两个台阶，到达下标为 9 的台阶。 - 支付 1 ，向上爬一个台阶，到达楼梯顶部。 总花费为 6 。

### 思路

参考上题爬楼梯的思路，楼梯顶部可以看作是下标n，到达n可以从n-1爬一步，也可以从n-2爬2步，所以花费就取这两种方法的最小值。于是dp[i]表示到达下标为i的最小花费，最后返回dp[n]即可，n为cost.size()。

### 代码

```C++
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        int n = cost.size();
        vector<int> dp(n + 1);
        dp[0] = 0, dp[1] = 0;
        for (int i = 2; i <= n; i++) {
            dp[i] = min(dp[i - 2] + cost[i - 2], dp[i - 1] + cost[i - 1]);
        }
        return dp[n];
    }
};
```

### 时空复杂度

时间复杂度：时间复杂度为O(n).

空间复杂度：空间复杂度为O(n).