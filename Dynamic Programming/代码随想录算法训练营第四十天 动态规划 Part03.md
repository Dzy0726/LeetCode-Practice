# 代码随想录算法训练营第四十一天| 动态规划 Part03

## 今日题目

343.[整数拆分](https://leetcode.cn/problems/integer-break/)

96.[不同的二叉搜索树](https://leetcode.cn/problems/unique-binary-search-trees/)

## LeetCode 343.整数拆分

### 题目

给定一个正整数 `n` ，将其拆分为 `k` 个 **正整数** 的和（ `k >= 2` ），并使这些整数的乘积最大化。

返回 *你可以获得的最大乘积* 。

> 示例 1:
>
> 输入: n = 2 输出: 1 解释: 2 = 1 + 1, 1 × 1 = 1。
>
> 示例 2:
>
> 输入: n = 10 输出: 36 解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。

### 思路

这也能过……几乎是枚举法了。看了提示2让找出7~10的规律，我发现都是3 * n-3的最大值。

比如7：3* 4的最大值，4的最大值是 4= 2 + 2， 2*2 =4，所以3*4 =12；

8：3*5的最大值 = 3*6 = 18……

枚举到13发现基本正确，结果代码通过了……

初始化0~6的最大值，从7开始用循环计算。

### 代码

```C++
class Solution {
public:
    int integerBreak(int n) {
        vector<int> dp(59);
        dp[0] = 0, dp[1] = 0, dp[2] = 1, dp[3] = 2, dp[4] = 4, dp[5] = 6, dp[6] = 9;
        for (int i = 7; i <= n; i++) {
            dp[i] = 3 * dp[i - 3];
        }
        return dp[n];
    }
};
```

### 时空复杂度

时间复杂度：时间复杂度为O(n).

空间复杂度：空间复杂度为O(n).给定了n <=58，所以数组大小为59.

### 学习与小结

显然是运气好把这道题AC了，还得学习正确的解法：

1. 确定dp数组（dp table）以及下标的含义

dp[i]：分拆数字i，可以得到的最大乘积为dp[i]。

1. 确定递推公式

其实可以从1遍历j，然后有两种渠道得到dp[i].

一个是j * (i - j) 直接相乘。

一个是j * dp[i - j]，相当于是拆分(i - j)。

**j怎么就不拆分呢？**

j是从1开始遍历，拆分j的情况，在遍历j的过程中其实都计算过了。那么从1遍历j，比较(i - j) * j和dp[i - j] * j 取最大的。递推公式：dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));

也可以这么理解，j * (i - j) 是单纯的把整数拆分为两个数相乘，而j * dp[i - j]是拆分成两个以及两个以上的个数相乘。

如果定义dp[i - j] * dp[j] 也是默认将一个数强制拆成4份以及4份以上了。

所以递推公式：dp[i] = max({dp[i], (i - j) * j, dp[i - j] * j});

那么在取最大值的时候，为什么还要比较dp[i]呢？

因为在递推公式推导的过程中，每次计算dp[i]，取最大的而已。

1. dp的初始化

只初始化dp[2] = 1，从dp[i]的定义来说，拆分数字2，得到的最大乘积是1；dp[0]和dp[1]没有任何意义！

1. 确定遍历顺序

确定遍历顺序，先来看看递归公式：dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));

dp[i] 是依靠 dp[i - j]的状态，所以遍历i一定是从前向后遍历，先有dp[i - j]再有dp[i]。

```C++
for (int i = 3; i <= n ; i++) {
    for (int j = 1; j < i - 1; j++) {
        dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));
    }
}
```

**拆分一个数n 使之乘积最大，那么一定是拆分成m个近似相同的子数相乘才是最大的。**

例如 6 拆成 3 * 3， 10 拆成 3 * 3 * 4。 100的话也是拆成m个近似数组的子数 相乘才是最大的。

只不过我们不知道m究竟是多少而已，但可以明确的是m一定大于等于2，既然m大于等于2，也就是 最差也应该是拆成两个相同的 可能是最大值。

那么 j 遍历，只需要遍历到 n/2 就可以，后面就没有必要遍历了，一定不是最大值。

```C++
for (int i = 3; i <= n ; i++) {
    for (int j = 1; j <= i / 2; j++) {
        dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));
    }
}
```

所以最终代码为：

```C++
class Solution {
public:
    int integerBreak(int n) {
        vector<int> dp(n + 1);
        dp[2] = 1;
        for (int i = 3; i <= n; i++) {
            int curMax = 0;
            for (int j = 1; j < i - 1; j++) {
                curMax = max(j * (i - j), j * dp[i - j]);
                dp[i] = max(dp[i], curMax);
            }
        }
        return dp[n];
    }
};
```

## LeetCode 96.不同的二叉搜索树

### 题目

给你一个整数 `n` ，求恰由 `n` 个节点组成且节点值从 `1` 到 `n` 互不相同的 **二叉搜索树** 有多少种？返回满足题意的二叉搜索树的种数。

> ![img](https://pkdwxagc9o.feishu.cn/space/api/box/stream/download/asynccode/?code=YTgyZGY5ZjFhOTM2MDYwYWNhMGIzMzZkMjRhNTIwYzdfU3JPb290VThKMjZMMjNzckJvbXh2Qk05S3JGemNuVjlfVG9rZW46RGdsNmJmcjAxb2VYN3B4dFJWUmN0YWR3bmpnXzE3MDcxMzYxNDM6MTcwNzEzOTc0M19WNA)
>
> 输入：n = 3 输出：5

### 思路

一开始画图总觉得有些规律，但是还是没找出来。

当1为头结点的时候，其右子树有两个节点，这两个节点的布局和n=2时的两个情况相同，不说具体的根节点数值，而是说右子树的整体布局；

当3为头结点的时候，其左子树有两个节点，这两个节点的布局和n=2的时候相同；

当2为头节点的时候，左子树有一个节点，右子树有一个节点，左右两棵子树的布局可以看作都和n=1的时候布局相同。

这样的话就可以找到递推公式：

dp[3] = dp[0]*dp[2]+dp[1]*dp[1]+dp[2]*dp[0]

即：

dp[n] = dp[0]*dp[n-1]+dp[1]*dp[n-2]+……+dp[n-1]*dp[0]

dp[n] = sum(dp[i]*dp[n - i -1])

在代码中可以写成：

dp[i] += dp[j - 1] * dp[i - j];j-1 为j为头结点左子树节点数量，i-j 为以j为头结点右子树节点数量。

### 代码

```C++
class Solution {
public:
    int numTrees(int n) {
        vector<int> dp(n + 1);
        dp[0] = 1, dp[1] = 1, dp[2] = 2;
        for (int i = 3; i <= n; i++) {
            for (int j = 1; j <= i; j++) {
                dp[i] += dp[j - 1] * dp[i - j]; 
            }
        }
        return dp[n];
    }
};
```

### 时空复杂度

时间复杂度：时间复杂度为O(n^2).

空间复杂度：空间复杂度为O(n).

### 学习与小结

1. 确定dp数组（dp table）以及下标的含义

dp[i] ： 1到i为节点组成的二叉搜索树的个数为dp[i]。

也可以理解是i个不同元素节点组成的二叉搜索树的个数为dp[i] ，都是一样的。

1. 确定递推公式

在上面的分析中，其实已经看出其递推关系， dp[i] += dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量]

j相当于是头结点的元素，从1遍历到i为止。

所以递推公式：dp[i] += dp[j - 1] * dp[i - j]; ，j-1 为j为头结点左子树节点数量，i-j 为以j为头结点右子树节点数量

1. dp数组如何初始化

初始化，只需要初始化dp[0]就可以了，推导的基础，都是dp[0]。

那么dp[0]应该是多少呢？

从定义上来讲，空节点也是一棵二叉树，也是一棵二叉搜索树，这是可以说得通的。

从递归公式上来讲，dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量] 中以j为头结点左子树节点数量为0，也需要dp[以j为头结点左子树节点数量] = 1， 否则乘法的结果就都变成0了。

所以初始化dp[0] = 1

1. 确定遍历顺序

首先一定是遍历节点数，从递归公式：dp[i] += dp[j - 1] * dp[i - j]可以看出，节点数为i的状态是依靠 i之前节点数的状态。

那么遍历i里面每一个数作为头结点的状态，用j来遍历。